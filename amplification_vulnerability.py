import ipaddress
import logging
import os
import time
from multiprocessing import Pool
from threading import Thread

import random_permutation
from scapy.all import *
from scapy.contrib.rtps import RTPS
from scapy.contrib.rtps.pid_types import *
from scapy.contrib.rtps.rtps import *
from scapy.layers.inet import IP, UDP

HOST_ID = 0x010F4E32
APP_ID = 0x0915C6E7
INSTANCE_ID = 0x00000000

METATRAFFIC_UNICAST_PORT = 7410
DEFAULT_UNICAST_PORT = 7411
COLLECTOR_IP = os.getenv("COLLECTOR_SERVER_IP", "52.15.115.111")

PORTS_TO_SCAN = [7400, 7410, 7411, 7412]

L3_SOCKET = conf.L3socket()

RTPS_PACKET = RTPS(
    # Using 2.3 for protocol version since ROS 2
    # Vendor is eProsima - Fast-RTPS "01.15"
    protocolVersion=ProtocolVersionPacket(major=2, minor=3),
    vendorId=VendorIdPacket(vendor_id=RawVal("\x01\x0f")),
    # Cyclone DDS
    # protocolVersion=ProtocolVersionPacket(major=2, minor=1),
    # vendorId=VendorIdPacket(vendor_id=RawVal("\x01\x10")),
    # Taken directly from Wireshark packet. How are these values generated?
    guidPrefix=GUIDPrefixPacket(
        hostId=HOST_ID,
        appId=APP_ID,
        instanceId=INSTANCE_ID,
    ),
    magic=b"RTPS",
) / RTPSMessage(
    submessages=[
        RTPSSubMessage_INFO_TS(
            submessageId=0x09,
            submessageFlags=0x01,
            octetsToNextHeader=8,
            ts_seconds=int(time.time()),
            ts_fraction=653661355,
        ),
        RTPSSubMessage_DATA(
            submessageId=0x15,
            submessageFlags=0x05,
            # octetsToNextHeader=277,
            octetsToNextHeader=216,
            extraFlags=0,
            octetsToInlineQoS=16,
            readerEntityIdKey=0x000100,
            readerEntityIdKind=0xC7,
            writerEntityIdKey=0x000100,
            writerEntityIdKind=0xC2,
            writerSeqNumLow=1,
            writerSeqNumHi=0,
            data=DataPacket(
                encapsulationKind=0x0003,
                encapsulationOptions=0x0000,
                parameterList=ParameterListPacket(
                    parameterValues=[
                        # Each packet has a parameter ID, length, and
                        # some data associated with it
                        PID_PROTOCOL_VERSION(
                            parameterId=0x0015,
                            parameterLength=4,
                            # Version 2.3
                            protocolVersion=ProtocolVersionPacket(major=2, minor=3),
                            # protocolVersion=ProtocolVersionPacket(major=2, minor=1),
                            padding=b"\x00\x00",
                        ),
                        PID_VENDOR_ID(
                            parameterId=0x0016,
                            parameterLength=4,
                            # Vendor ID 01.15 (eProsima - Fast-RTPS)
                            vendorId=VendorIdPacket(vendor_id=RawVal("\x01\x0f")),
                            # vendorId=VendorIdPacket(vendor_id=RawVal("\x01\x10")),
                            padding=b"\x00\x00",
                        ),
                        PID_PARTICIPANT_GUID(
                            parameterId=0x0050,
                            parameterLength=16,
                            guid=GUIDPacket(
                                hostId=HOST_ID,
                                appId=APP_ID,
                                instanceId=INSTANCE_ID,
                                entityId=0x000001C1,
                            ),
                        ),
                        PID_METATRAFFIC_UNICAST_LOCATOR(
                            parameterId=0x0032,
                            parameterLength=24,
                            locator=LocatorPacket(
                                locatorKind=0x1,
                                port=METATRAFFIC_UNICAST_PORT,
                                address=COLLECTOR_IP,
                            ),
                        ),
                        PID_DEFAULT_UNICAST_LOCATOR(
                            parameterId=0x0031,
                            parameterLength=24,
                            locator=LocatorPacket(
                                locatorKind=0x00000001,
                                port=DEFAULT_UNICAST_PORT,
                                address=COLLECTOR_IP,
                            ),
                        ),
                        # PID_DEFAULT_MULTICAST_LOCATOR(
                        #     parameterId=0x0048,
                        #     parameterLength=24,
                        #     locator=LocatorPacket(
                        #         locatorKind=0x1,
                        #         address=COLLECTOR_IP,
                        #         port=DEFAULT_UNICAST_PORT,
                        #     ),
                        # ),
                        # PID_METATRAFFIC_MULTICAST_LOCATOR(
                        #     parameterId=0x0048,
                        #     parameterLength=24,
                        #     locator=LocatorPacket(
                        #         locatorKind=0x1,
                        #         address=COLLECTOR_IP,
                        #         port=DEFAULT_UNICAST_PORT,
                        #     ),
                        # ),
                        PID_PARTICIPANT_LEASE_DURATION(
                            parameterId=0x0002,
                            parameterLength=8,
                            parameterData=b"\x14\x00\x00\x00\x00\x00\x00\x00",
                        ),
                        PID_BUILTIN_ENDPOINT_SET(
                            parameterId=0x0058,
                            parameterLength=4,
                            parameterData=b"\x00\x0f\x0c\x3f",
                        ),
                        PID_ENTITY_NAME(
                            parameterId=0x0062,
                            parameterLength=8,
                            parameterData=b"\x02\x00\x00\x00\x2f\x00\x00\x00",
                        ),
                        PID_USER_DATA(
                            parameterId=0x002C,
                            parameterLength=16,
                            parameterData=b"\x0b\x00\x00\x00\x65\x6e\x63\x6c\x61\x76\x65\x3d\x2f\x3b\x00\x00",
                        ),
                        PID_PROPERTY_LIST(
                            parameterId=0x0059,
                            parameterLength=40,
                            parameterData=b"\x01\x00\x00\x00\x11\x00\x00\x00\x50\x41\x52\x54\x49\x43\x49\x50\x41\x4e\x54\x5f\x54\x59\x50\x45\x00\x00\x00\x00\x07\x00\x00\x00\x53\x49\x4d\x50\x4c\x45\x00\x00",
                        ),
                    ],
                    sentinel=PID_SENTINEL(parameterId=1, parameterLength=0),
                ),
            ),
        ),
    ]
)

BLOCKLIST = [
    "0.0.0.0/8",  # "This" network
    "10.0.0.0/8",  # Private network
    "100.64.0.0/10",  # Carrier-grade NAT,
    "127.0.0.0/8",  # Loopback
    "169.254.0.0/16",  # Link-local
    "172.16.0.0/12",  # Private network
    "192.0.0.0/24",  # IETF Protocol Assignments
    "192.0.2.0/24",  # TEST-NET-1
    "192.88.99.0/24",  # 6to4 relay anycast
    "192.168.0.0/16",  # Private network
    "198.18.0.0/15",  # Benchmark testing
    "198.51.100.0/24",  # TEST-NET-2
    "203.0.113.0/24",  # TEST-NET-3
    "224.0.0.0/4",  # Multicast
    "240.0.0.0/4",  # Reserved for future use
    "255.255.255.255/32",  # Broadcast
]

logger = logging.getLogger(__name__)
logging.basicConfig(
    filename=os.path.join(os.path.dirname(os.path.abspath(__file__)), "scanner.log"),
    level=logging.INFO,
    format="%(asctime)s %(levelname)s %(name)s %(message)s",
    filemode="a",
)


def ip_range():
    for ip_int in random_permutation.RandomPermutation(2**32):
        ip_addr = ipaddress.ip_address(ip_int)
        fail = False
        for block in BLOCKLIST:
            if ip_addr in ipaddress.ip_network(block):
                fail = True
                break
        if fail:
            continue
        yield ip_addr.exploded


def main():
    """
    Read IPs from stdin, send RTPS packets to each IP on the specified ports.
    The scanned IPs are saved to a file, and the count of scanned IPs is saved
    to another file.

    If an exception occurs, it is logged, and the script continues to the next IP.
    The script is designed to be run in a loop, reading IPs from stdin.
    """
    with Pool() as pool:
        results = pool.imap(amplify_ip, ip_range(), chunksize=1000)

        # Need to iterate through results to make sure all processes run
        for _ in results:
            pass


def amplify_ip(ip):
    """
    Scan the ports provided in PORTS_TO_SCAN for the given IP concurrently.
    """
    for port in PORTS_TO_SCAN:
        scan_thread = Thread(target=send_packet, args=[ip, port])
        scan_thread.start()

    with open("scanned_ips.txt", "a") as scanned_ips_f:
        scanned_ips_f.write(ip + "\n")
        scanned_ips_f.flush()


def send_packet(ip, port):
    """
    Send RTPS packet to the specified IP and port using L3_SOCKET. Using the
    same socket for sending packets speeds up the process significantly.
    """
    L3_SOCKET.send(IP(dst=ip) / UDP(sport=33653, dport=port) / RTPS_PACKET)


if __name__ == "__main__":
    main()
